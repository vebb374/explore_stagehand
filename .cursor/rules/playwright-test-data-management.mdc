---
description: 
globs: tests/**/*.ts
alwaysApply: false
---
# Playwright Test Data Management

Each test should properly handle test data to ensure isolation and maintainability. This rule provides guidance on test data management in our TypeScript Playwright framework.

## Key Principles

1. **Test Isolation**: Each test should be completely independent
2. **Data Creation**: Tests should create or fetch their own test data
3. **Cleanup**: Tests should clean up any data they create
4. **No Shared State**: Don't rely on data created by other tests

## Credential Management

We use two main approaches for handling test credentials:

### 1. Fixtures for Dynamic Credentials

Use fixtures to generate or retrieve unique credentials, especially for candidate tests:

```typescript
// tests/candidate/login.spec.ts
import { test, expect } from 'utils/fixtures.js';
import { loginAsCandidate } from 'pages/common-components/login/login-page.js';

test.describe('Candidate Login', () => {
  test('should login as candidate with unique credentials', async ({ page, getUniqueCandidateCredentials }) => {
    const { email, password } = getUniqueCandidateCredentials;
    
    // Navigate to login page and login with unique candidate credentials
    await loginAsCandidate(page, email, password);
    
  });
});
```

### 2. Utility Functions for Known Test Data

For recruiter/admin tests, use utility functions to access known test data:

```typescript
// tests/recruiter/login/test_login.spec.ts
import { test, expect } from "@playwright/test";
import { loginAsRecruiter } from "pages/common-components/login/login-page.js";
import { TopNavbarComponent } from "pages/recruiter/assessment/top-navbar.component.js";
import { getCompanyData } from "utils/index.js";

test.describe("Recruiter Login", () => {
  test("should login successfully and see assessments link", async ({ page }) => {
    const { ADMIN, PASSWORD } = getCompanyData("qa_test_company_15");
    await loginAsRecruiter(page, ADMIN, PASSWORD);
    // Test assertions...
  });
});
```

## Test Data Storage

Keep test data organized in appropriate directories:

```
test-data/
  ├── candidates/           # Candidate test data
  │   └── infy_pref_test_users_40K/  # Bulk test user data
  └── companies/            # Company/recruiter test data
```

## Dynamic Data Generation

We use the `test-data-generator.ts` utility to create dynamic test data that ensures test independence.

### About test-data-generator.ts

The test data generator utility located at `utils/test-data-generator.ts` provides functions for generating random, unique test data for tests:

```typescript
// utils/test-data-generator.ts
export function generateRandomEmail(): string {
  return `test-${Date.now()}@example.com`;
}

export function generateRandomAssessmentName(): string {
  return `Test Assessment ${Date.now()}`;
}
```

### Usage Examples

Import and use these functions in your tests to create unique test data:

```typescript
// Example test using dynamic data generation
import { test, expect } from '@playwright/test';
import { AssessmentCreationPage } from 'pages/recruiter/assessment/assessment-creation-page';
import { generateRandomEmail, generateRandomAssessmentName } from 'utils/test-data-generator';

test.describe('Assessment Creation', () => {
  test('should create a new assessment with unique name', async ({ page }) => {
    const assessmentPage = new AssessmentCreationPage(page);
    const uniqueEmail = generateRandomEmail();
    const uniqueAssessmentName = generateRandomAssessmentName();
    
    await assessmentPage.navigateTo();
    await assessmentPage.fillAssessmentDetails({
      name: uniqueAssessmentName,
      adminEmail: uniqueEmail
    });
    await assessmentPage.submitForm();
    
    await expect(assessmentPage.successMessage).toBeVisible();
  });
});
```

### Best Practices for Dynamic Data Generation

1. **Always use the utility functions** rather than creating inline random values
2. **Use descriptive prefixes** in generated data to make test debugging easier
3. **Consider adding more specialized generators** as project needs grow
4. **Ensure timestamp uniqueness** by adding minimal delays when creating multiple records

For adding new generator functions, follow this pattern:

```typescript
// New generator function example
export function generateRandomCompanyName(): string {
  return `Test Company ${Date.now()}`;
}
```

