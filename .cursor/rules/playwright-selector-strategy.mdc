---
description: this provides details about  priority of  playwright selectors
globs: 
alwaysApply: false
---
# Playwright Selector Strategy

This rule provides guidance on how to create robust and maintainable selectors for Playwright tests.
When selecting elements in your Playwright tests, prefer selectors that query for elements in a way that reflects how users would interact with them. This makes tests more resilient to changes and better represents user behavior.

## Selector Priority

When creating selectors, use the following priority order:

1. **Accessibility attributes** (preferred)
   - Role: `page.getByRole('button', { name: 'Invite candidates' })`
   - Label: `page.getByLabel('Email')`
   - Text: `page.getByText('You can only add 3 more candidates')`

2. **Test attributes** (when accessibility attributes are not available)
   - Data attributes: `page.locator('[data-testid="invite-button"]')`
   - ARIA attributes: `page.locator('[aria-label="Close modal"]')`

3. **CSS selectors** (use when options 1 and 2 aren't available)
   - Class: `page.locator('.react-datepicker__day')`
   - Combination: `page.locator('.modal-header .close-button')`

4. **XPath** (last resort, use only when necessary)
   - `page.locator('//div[contains(@class,"test-title")]')`

## Best Practices

1. **Be specific but flexible**
   - Too specific: `page.locator('.form-row:nth-child(2) input')` (breaks if structure changes)
   - Better: `page.getByRole('textbox', { name: 'Email' })`

2. **Filter when needed**
   - Use `filter()` to narrow down selection: 
     ```typescript
     page.locator('button').filter({ hasText: 'Invite' })
     ```

3. **Combine selectors for robustness**
   - Use `and()` or multiple filters:
     ```typescript
     page.getByRole('button').and(page.getByText('Submit'))
     ```

4. **Use context when needed**
   - Scope selectors to parent elements:
     ```typescript
     const modal = page.locator('.modal');
     const submitButton = modal.getByRole('button', { name: 'Submit' });
     ```

5. **Avoid selectors based on position**
   - Avoid: `page.locator('tr').nth(2)` (breaks if order changes)
   - Better: `page.locator('tr').filter({ hasText: 'expectedText' })`

## Examples from the Codebase

```typescript
// Good: Using role selectors
this.emailInput = page.getByRole('textbox', { name: 'olivia@gmail.com' });
this.addCandidateButton = page.getByRole('button', { name: 'Add candidate' });

// Good: Filtering by text
this.candidatesTable = page.locator('table').filter({ hasText: /Email/ });

// Good: Combining multiple attributes
this.inviteCandidatesButton = page.getByRole('button', {
    name: 'Invite candidates',
    exact: true,
});

// When needed: XPath for complex structures
this.closeModalButton = page.locator(
    '//div[contains(@class,"ql-flyout-main")]/button[@class="close-btn"]'
);
```

## Selector Priority (In Order of Preference)

1. `getByRole` - Queries for elements by their ARIA role, accessible name, and/or accessible state
2. `getByLabelText` - Queries for form elements associated with label text
3. `getByPlaceholderText` - Queries for elements with placeholder text
4. `getByText` - Queries for elements containing specific text
5. `getByDisplayValue` - Queries for form elements with specific display value
6. `getByAltText` - Queries for elements with alt text (usually images)
7. `getByTitle` - Queries for elements with title attribute
8. `getByTestId` - Queries for elements with data-testid attribute (use only when above options don't work)

## Good Practices

```typescript
// GOOD - Using semantic selectors in page objects
export class LoginPage {
  readonly page: Page;
  readonly saveButton: Locator;
  readonly nameInput: Locator;
  readonly emailField: Locator;
  readonly errorMessage: Locator;
  readonly profileImage: Locator;
  
  constructor(page: Page) {
    this.page = page;
    this.saveButton = page.getByRole('button', { name: 'Save' });
    this.nameInput = page.getByLabel('Full Name');
    this.emailField = page.getByPlaceholderText('Enter your email');
    this.errorMessage = page.getByText('Invalid credentials');
    this.profileImage = page.getByAltText('User profile');
  }
}

// In tests - access through fixtures
test('should submit form', async ({ loginPage }) => {
  await loginPage.nameInput.fill('John Doe');
  await loginPage.emailField.fill('john@example.com');
  await loginPage.saveButton.click();
});
```

## Bad Practices to Avoid

```typescript
// BAD - Using CSS selectors tied to implementation
export class LoginPage {
  readonly page: Page;
  readonly saveButton: Locator;
  readonly nameInput: Locator;
  readonly errorMessage: Locator;
  readonly profileImage: Locator;
  
  constructor(page: Page) {
    this.page = page;
    this.saveButton = page.locator('.btn-primary');
    this.nameInput = page.locator('input#name_field');
    this.errorMessage = page.locator('.error-container > p');
    this.profileImage = page.locator('.profile-section img');
  }
}
```

## When to Use Test IDs

Only use test IDs as a last resort, when elements cannot be selected using more semantic methods:

```typescript
// Only when necessary - Using data-testid
export class SpecialComponent {
  readonly container: Locator;
  
  constructor(page: Page) {
    this.container = page.getByTestId('special-container');
  }
}
```

## Locating Elements Within Components

When working with components, define all locators relative to the component's container to ensure proper scoping:

```typescript
export class QuestionTableComponent {
  readonly container: Locator;
  readonly questionTypeHeader: Locator;
  readonly difficultyLevelCell: Locator;
  
  constructor(page: Page) {
    this.container = page.locator('[data-testid="question-table"]');
    this.questionTypeHeader = this.container.getByRole('columnheader', { name: 'Question type' });
    this.difficultyLevelCell = this.container.getByRole('cell', { name: 'Easy' });
  }
}
```
