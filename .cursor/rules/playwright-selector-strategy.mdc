---
description: this provides details about  priority of  playwright selectors
globs: 
alwaysApply: false
---
# Playwright Selector Strategy

When selecting elements in your Playwright tests, prefer selectors that query for elements in a way that reflects how users would interact with them. This makes tests more resilient to changes and better represents user behavior.

## Selector Priority (In Order of Preference)

1. `getByRole` - Queries for elements by their ARIA role, accessible name, and/or accessible state
2. `getByLabelText` - Queries for form elements associated with label text
3. `getByPlaceholderText` - Queries for elements with placeholder text
4. `getByText` - Queries for elements containing specific text
5. `getByDisplayValue` - Queries for form elements with specific display value
6. `getByAltText` - Queries for elements with alt text (usually images)
7. `getByTitle` - Queries for elements with title attribute
8. `getByTestId` - Queries for elements with data-testid attribute (use only when above options don't work)

## Good Practices

```typescript
// GOOD - Using semantic selectors in page objects
export class LoginPage {
  readonly page: Page;
  readonly saveButton: Locator;
  readonly nameInput: Locator;
  readonly emailField: Locator;
  readonly errorMessage: Locator;
  readonly profileImage: Locator;
  
  constructor(page: Page) {
    this.page = page;
    this.saveButton = page.getByRole('button', { name: 'Save' });
    this.nameInput = page.getByLabel('Full Name');
    this.emailField = page.getByPlaceholderText('Enter your email');
    this.errorMessage = page.getByText('Invalid credentials');
    this.profileImage = page.getByAltText('User profile');
  }
}

// In tests - access through fixtures
test('should submit form', async ({ loginPage }) => {
  await loginPage.nameInput.fill('John Doe');
  await loginPage.emailField.fill('john@example.com');
  await loginPage.saveButton.click();
});
```

## Bad Practices to Avoid

```typescript
// BAD - Using CSS selectors tied to implementation
export class LoginPage {
  readonly page: Page;
  readonly saveButton: Locator;
  readonly nameInput: Locator;
  readonly errorMessage: Locator;
  readonly profileImage: Locator;
  
  constructor(page: Page) {
    this.page = page;
    this.saveButton = page.locator('.btn-primary');
    this.nameInput = page.locator('input#name_field');
    this.errorMessage = page.locator('.error-container > p');
    this.profileImage = page.locator('.profile-section img');
  }
}
```

## When to Use Test IDs

Only use test IDs as a last resort, when elements cannot be selected using more semantic methods:

```typescript
// Only when necessary - Using data-testid
export class SpecialComponent {
  readonly container: Locator;
  
  constructor(page: Page) {
    this.container = page.getByTestId('special-container');
  }
}
```

## Locating Elements Within Components

When working with components, define all locators relative to the component's container to ensure proper scoping:

```typescript
export class QuestionTableComponent {
  readonly container: Locator;
  readonly questionTypeHeader: Locator;
  readonly difficultyLevelCell: Locator;
  
  constructor(page: Page) {
    this.container = page.locator('[data-testid="question-table"]');
    this.questionTypeHeader = this.container.getByRole('columnheader', { name: 'Question type' });
    this.difficultyLevelCell = this.container.getByRole('cell', { name: 'Easy' });
  }
}
```
