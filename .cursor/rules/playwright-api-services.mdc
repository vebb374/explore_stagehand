---
description:
globs:
alwaysApply: false
---
# Playwright API Services and Testing

This rule provides guidance on how to structure and use API services for testing in our Playwright framework.

## API Client Structure

The API client architecture follows a modular approach:

```
utils/api/
  ├── api-client.ts           # Main client class that aggregates all services
  ├── logger.ts               # Logging utility for API calls
  └── services/               # Individual API domain services
      ├── auth.ts             # Authentication service
      └── [other-services].ts # Other domain-specific services
```

1. `ApiClient`: Central client that provides access to all services
2. Individual services in the `services/` directory, each focusing on a specific domain

## API Service Implementation

When creating a new API service:

1. **Create a new file** in `utils/api/services/` named after the domain
2. **Implement a class** with methods for API operations
3. **Register the service** in the ApiClient class

Example of an API service:

```typescript
// utils/api/services/assessment.ts
import { APIRequestContext, APIResponse } from "@playwright/test";
import { Logger } from "../logger.js";

export class AssessmentApi {
    private request: APIRequestContext;
    private baseURL: string;
    private logger: Logger;

    constructor(request: APIRequestContext, logger?: Logger) {
        this.request = request;
        // Use the provided logger or create a new one
        this.logger = logger
            ? logger.withClassName(this.constructor.name)
            : new Logger({ serviceName: this.constructor.name });

        // Ensure baseURL has a fallback if env variables are not set
        this.baseURL = process.env.API_BASE_URL || process.env.BASE_URL || "https://app.hackerearth.com";
    }

    async getAssessments(): Promise<APIResponse> {
        this.logger.info("Fetching assessments");
        const response = await this.request.get(`${this.baseURL}/recruiter/api/assessments/`);
        return response;
    }

    // Add other assessment-related methods here
}
```

## Adding a New Service to ApiClient

Register your new service in the ApiClient class:

```typescript
// utils/api/api-client.ts
import { APIRequestContext } from "@playwright/test";
import { AuthApi } from "./services/auth.js";
import { AssessmentApi } from "./services/assessment.js";  // Import new service
import { Logger } from "./logger.js";

export class ApiClient {
    readonly auth: AuthApi;
    readonly assessment: AssessmentApi;  // Add new service property
    readonly request: APIRequestContext;
    readonly logger: Logger;

    constructor(request: APIRequestContext, clientType: string = "") {
        this.request = request;
        this.logger = new Logger({ clientType });
        this.auth = new AuthApi(request, this.logger);
        this.assessment = new AssessmentApi(request, this.logger);  // Initialize new service
    }
}
```

## API Client Types in Tests

There are three types of API clients available in fixtures:

1. **currentSessionApiClient**: Uses the current browser session context
   - Use when tests need to make API calls in the same session as the browser
   - Useful for hybrid UI/API tests

2. **IsolatedAPIClient**: Independent API client
   - Use for pure API tests or when you need an isolated session
   - Clean state, not sharing cookies with the browser

3. **IsolatedAPIClient2**: Second independent API client
   - Used when you need multiple isolated API clients in a single test
   - Useful for testing multiple user scenarios

## Using API Clients in Tests

### In Pure API Tests

```typescript
// tests/recruiter/api/assessment.spec.ts
import { test, expect } from "./fixtures.js";

test("should fetch assessments via API", async ({ apiClient }) => {
    // Login
    await apiClient.auth.login("admin@example.com", "password");
    
    // Call API method
    const response = await apiClient.assessment.getAssessments();
    
    // Assert on response
    expect(response.ok()).toBe(true);
    const data = await response.json();
    expect(data.items).toBeDefined();
});
```

### In UI Tests with API Support

```typescript
// tests/recruiter/assessment/overview.spec.ts
import { test, expect } from "./fixtures.js";
import { getCompanyData } from "utils";

test("should display assessment created via API", async ({ 
    assessmentOverviewPage, 
    IsolatedAPIClient, 
    page 
}) => {
    // 1. Setup data via API
    const { ADMIN, PASSWORD } = getCompanyData("qa_test_company_15");
    await IsolatedAPIClient.auth.login(ADMIN, PASSWORD);
    
    // Create assessment via API
    const createResponse = await IsolatedAPIClient.assessment.createAssessment({
        name: "Test Assessment",
        description: "Created via API"
    });
    expect(createResponse.ok()).toBe(true);
    const { id } = await createResponse.json();
    
    // 2. Login in the UI
    await page.goto("/recruiter/login");
    // Login handled by the page fixture
    
    // 3. Navigate to the created assessment and verify
    await assessmentOverviewPage.navigateTo(id);
    await expect(assessmentOverviewPage.pageTitle).toBeVisible();
});
```

### Using Current Session API Client

```typescript
test("should use API in current browser session", async ({ 
    page, 
    currentSessionApiClient 
}) => {
    // Login via UI
    await page.goto("/recruiter/login");
    await page.getByLabel("Email").fill("admin@example.com");
    await page.getByLabel("Password").fill("password");
    await page.getByRole("button", { name: "Login" }).click();
    
    // User is now logged in, use the same session for API calls
    const response = await currentSessionApiClient.assessment.getAssessments();
    expect(response.ok()).toBe(true);
    
    // Use the API response data in UI verification
    const data = await response.json();
    const firstAssessmentId = data.items[0].id;
    
    // Navigate to the first assessment
    await page.goto(`/recruiter/assessment/${firstAssessmentId}`);
    // Verify some UI element
});
```

## Best Practices

1. **Prefer UI Tests for User Flows**
   - Use API tests for backend validation and data setup
   - Use UI tests for user-facing functionality

2. **Use API for Test Data Setup**
   - Create test data via API before UI tests when possible
   - Clean up test data via API after tests

3. **Handle Authentication Properly**
   - Always login before making API calls
   - For `currentSessionApiClient`, ensure UI login has completed

4. **Log API Operations**
   - Use the logger to record API operations for debugging
   - Include useful information in log messages

5. **Handle Errors Gracefully**
   - Check response status and provide meaningful error messages
   - Include response body in error messages for debugging
