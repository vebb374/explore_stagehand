---
description: 
globs: tests/**/*.ts
alwaysApply: false
---
# Playwright Test Best Practices

These rules ensure our tests are maintainable, reliable, and focused.

## Test Structure

1. **Follow the AAA Pattern**: Arrange, Act, Assert
   ```typescript
   test('should submit form successfully', async () => {
     // Arrange - setup the test
     await page.goto('/contact');
     
     // Act - perform the action
     await page.getByLabel('Name').fill('John Doe');
     await page.getByLabel('Email').fill('john@example.com');
     await page.getByRole('button', { name: 'Submit' }).click();
     
     // Assert - verify the outcome
     await expect(page.getByText('Thank you for your submission')).toBeVisible();
   });
   ```

2. **One Assertion Per Test**
   Focus each test on verifying one specific behavior. Multiple assertions are acceptable only if they're checking the same logical behavior.

## Waiting Strategies

1. **Avoid Arbitrary Waits**
   ```typescript
   // BAD
   await page.waitForTimeout(5000); // Arbitrary delay
   
   // GOOD
   await page.waitForLoadState('domcontentloaded');
   await page.waitForResponse(res => res.url().includes('/api/data') && res.status() === 200);
   await expect(page.getByRole('heading')).toBeVisible();
   ```

2. **Create Helper Functions for Common Wait Patterns**
   ```typescript
   // utils/wait-helpers.ts
   export async function waitForApiResponse(page: Page, urlPattern: string, statusCode = 200): Promise<void> {
     await page.waitForResponse(
       (res) => res.url().includes(urlPattern) && res.status() === statusCode
     );
   }
   ```

## Avoid Conditionals in Tests

Tests should be deterministic. If you need conditional logic, it usually means you should create separate test cases.

```typescript
// BAD
test('conditional test', async () => {
  if (await page.getByText('Welcome').isVisible()) {
    // test something
  } else {
    // test something else
  }
});

// GOOD - Split into separate tests
test('when welcome message is visible', async () => {
  await expect(page.getByText('Welcome')).toBeVisible();
  // test specific behavior
});

test('when welcome message is not visible', async () => {
  await expect(page.getByText('Welcome')).not.toBeVisible();
  // test different behavior
});
```

## Use Test Tagging

Tag tests to organize them by type, feature, or run location.

```typescript
test.describe('@functional Assessment Overview', () => {
  test('@smoke displays assessment details', async () => {
    // test implementation
  });
  
  test('@visual @desktop display layout', async () => {
    // test implementation
  });
});
```

## Handling Flaky Tests

1. **Fix Flaky Tests Immediately**: Make this a priority
2. **Mark Unfixable Tests**: If a test cannot be immediately fixed, mark it with `.fixme`

```typescript
test.fixme('flaky test that needs fixing', async () => {
  // This test will be skipped until fixed
});
```
