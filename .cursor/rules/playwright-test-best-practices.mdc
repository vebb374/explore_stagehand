---
description: 
globs: tests/**/*.ts
alwaysApply: false
---
# Playwright Test Best Practices

These rules ensure our tests are maintainable, reliable, and focused.

## Fixture-Based Testing

1. **Use Fixtures for Page Objects and Test Data**:
   - Each test group should have its own `fixtures.ts` file
   - Access page objects and test data through fixtures
   - Extend base fixtures with test-specific fixtures

   ```typescript
   // tests/recruiter/assessment/fixtures.ts
   import { test as base } from "utils/base-fixtures.js";
   import { AssessmentPage } from "pages/recruiter/assessment/AssessmentPage.js";

   export const test = base.extend<{
     assessmentPage: AssessmentPage;
   }>({
     assessmentPage: async ({ page }, use) => {
       await use(new AssessmentPage(page));
     }
   });

   export { expect } from "@playwright/test";
   ```

2. **Import Fixtures in Test Files**:
   ```typescript
   // tests/recruiter/assessment/overview.spec.ts
   import { test, expect } from './fixtures';
   
   test('should display assessment details', async ({ assessmentPage }) => {
     // Test implementation using the fixture
   });
   ```

## Test Structure

1. **Follow the AAA Pattern**: Arrange, Act, Assert
   ```typescript
   test('should submit form successfully', async ({ contactPage }) => {
     // Arrange - setup the test
     await contactPage.navigateTo();
     
     // Act - perform the action
     await contactPage.fillContactForm('John Doe', 'john@example.com');
     await contactPage.submitForm();
     
     // Assert - verify the outcome
     await expect(contactPage.successMessage).toBeVisible();
   });
   ```

2. **One Assertion Per Test**
   Focus each test on verifying one specific behavior. Multiple assertions are acceptable only if they're checking the same logical behavior.

3. **Assert using Page Object elements**
   ```typescript
   // Use page object elements in assertions
   await expect(assessmentPage.element1).toBeVisible();
   await expect(assessmentPage.element2).toHaveText('Expected text');
   ```

## Fixture Organization

1. **Base Fixtures**: Common fixtures used across the application
   - Location: `utils/base-fixtures.ts`
   - Example: `getUniqueCandidateCredentials`

2. **Test Group Fixtures**: Specific to a test group/folder
   - Location: `tests/[user-type]/[feature]/fixtures.ts`
   - Example: Assessment-specific page objects and data

3. **Test File Imports**: Always import from the closest fixture file
   - Import from: `./fixtures` (in the same directory)

## Waiting Strategies

1. **Avoid Arbitrary Waits**
   ```typescript
   // BAD
   await page.waitForTimeout(5000); // Arbitrary delay
   
   // GOOD
   await page.waitForLoadState('domcontentloaded');
   await page.waitForResponse(res => res.url().includes('/api/data') && res.status() === 200);
   await expect(page.getByRole('heading')).toBeVisible();
   ```

2. **Create Helper Functions for Common Wait Patterns**
   ```typescript
   // utils/wait-helpers.ts
   export async function waitForApiResponse(page: Page, urlPattern: string, statusCode = 200): Promise<void> {
     await page.waitForResponse(
       (res) => res.url().includes(urlPattern) && res.status() === statusCode
     );
   }
   ```

## Avoid Conditionals in Tests

Tests should be deterministic. If you need conditional logic, it usually means you should create separate test cases.

```typescript
// BAD
test('conditional test', async ({ loginPage }) => {
  if (await loginPage.welcomeMessage.isVisible()) {
    // test something
  } else {
    // test something else
  }
});

// GOOD - Split into separate tests
test('when welcome message is visible', async ({ loginPage }) => {
  await expect(loginPage.welcomeMessage).toBeVisible();
  // test specific behavior
});

test('when welcome message is not visible', async ({ loginPage }) => {
  await expect(loginPage.welcomeMessage).not.toBeVisible();
  // test different behavior
});
```

## Use Test Tagging

Tag tests to organize them by type, feature, or run location.

```typescript
test.describe('@functional Assessment Overview', () => {
  test('@smoke displays assessment details', async ({ assessmentPage }) => {
    // test implementation
  });
  
  test('@visual @desktop display layout', async ({ assessmentPage }) => {
    // test implementation
  });
});
```

## Handling Flaky Tests

1. **Fix Flaky Tests Immediately**: Make this a priority
2. **Mark Unfixable Tests**: If a test cannot be immediately fixed, mark it with `.fixme`

```typescript
test.fixme('flaky test that needs fixing', async ({ loginPage }) => {
  // This test will be skipped until fixed
});
```
