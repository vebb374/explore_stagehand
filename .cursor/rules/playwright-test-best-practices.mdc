---
description: 
globs: 
alwaysApply: true
---
# Playwright Test Best Practices

These rules ensure our tests are maintainable, reliable, and focused.

## Fixture-Based Testing

1. **Use Fixtures for Page Objects, API Clients, and Test Data**:
   - Each test group should have its own `fixtures.ts` file
   - Access page objects, API clients, and test data through fixtures
   - Extend base fixtures with test-specific fixtures

   ```typescript
   // tests/recruiter/assessment/fixtures.ts
   import { test as base } from "utils/base-fixtures.js";
   import { AssessmentPage } from "pages/recruiter/assessment/AssessmentPage.js";
   import { ApiClient } from "utils/api/api-client.js";

   export const test = base.extend<{
     assessmentPage: AssessmentPage;
     currentSessionApiClient: ApiClient;
     IsolatedAPIClient: ApiClient;
   }>({
     assessmentPage: async ({ page }, use) => {
       await use(new AssessmentPage(page));
     },
     currentSessionApiClient: async ({ context }, use) => {
       const client = new ApiClient(context.request, "CurrentSession");
       await use(client);
       await context.request.dispose();
     },
     IsolatedAPIClient: async ({ request }, use) => {
       const client = new ApiClient(request, "IsolatedAPI");
       await use(client);
       await request.dispose();
     },
   });

   export { expect } from "@playwright/test";
   ```

2. **Import Fixtures in Test Files**:
   ```typescript
   // tests/recruiter/assessment/overview.spec.ts
   import { test, expect } from './fixtures';
   
   test('should display assessment details', async ({ assessmentPage }) => {
     // Test implementation using the fixture
   });
   ```

## Test Structure

1. **Follow the AAA Pattern**: Arrange, Act, Assert
   ```typescript
   test('should submit form successfully', async ({ contactPage }) => {
     // Arrange - setup the test
     await contactPage.navigateTo();
     
     // Act - perform the action
     await contactPage.fillContactForm('John Doe', 'john@example.com');
     await contactPage.submitForm();
     
     // Assert - verify the outcome
     await expect(contactPage.successMessage).toBeVisible();
   });
   ```

2. **One Assertion Per Test**
   Focus each test on verifying one specific behavior. Multiple assertions are acceptable only if they're checking the same logical behavior.

3. **Assert using Page Object elements**
   ```typescript
   // Use page object elements in assertions
   await expect(assessmentPage.element1).toBeVisible();
   await expect(assessmentPage.element2).toHaveText('Expected text');
   ```

## Fixture Organization

1. **Base Fixtures**: Common fixtures used across the application
   - Location: `utils/base-fixtures.ts`
   - Example: `getUniqueCandidateCredentials`

2. **Test Group Fixtures**: Specific to a test group/folder
   - Location: `tests/[user-type]/[feature]/fixtures.ts`
   - Example: Assessment-specific page objects and data

3. **Test File Imports**: Always import from the closest fixture file
   - Import from: `./fixtures` (in the same directory)

## Waiting Strategies

1. **Avoid Arbitrary Waits**
   ```typescript
   // BAD
   await page.waitForTimeout(5000); // Arbitrary delay
   
   // GOOD
   await page.waitForLoadState('domcontentloaded');
   await page.waitForResponse(res => res.url().includes('/api/data') && res.status() === 200);
   await expect(page.getByRole('heading')).toBeVisible();
   ```

2. **Create Helper Functions for Common Wait Patterns**
   ```typescript
   // utils/wait-helpers.ts
   export async function waitForApiResponse(page: Page, urlPattern: string, statusCode = 200): Promise<void> {
     await page.waitForResponse(
       (res) => res.url().includes(urlPattern) && res.status() === statusCode
     );
   }
   ```

## Avoid Conditionals in Tests

Tests should be deterministic. If you need conditional logic, it usually means you should create separate test cases.

```typescript
// BAD
test('conditional test', async ({ loginPage }) => {
  if (await loginPage.welcomeMessage.isVisible()) {
    // test something
  } else {
    // test something else
  }
});

// GOOD - Split into separate tests
test('when welcome message is visible', async ({ loginPage }) => {
  await expect(loginPage.welcomeMessage).toBeVisible();
  // test specific behavior
});

test('when welcome message is not visible', async ({ loginPage }) => {
  await expect(loginPage.welcomeMessage).not.toBeVisible();
  // test different behavior
});
```

## Use Test Tagging

Tag tests to organize them by type, feature, or run location.

```typescript
test.describe('@functional Assessment Overview', () => {
  test('@smoke displays assessment details', async ({ assessmentPage }) => {
    // test implementation
  });
  
  test('@visual @desktop display layout', async ({ assessmentPage }) => {
    // test implementation
  });
});
```

## API Testing Best Practices

1. **Separate API Test Files**:
   - Keep pure API tests in their own files/folders
   - Example: `tests/recruiter/api/assessments.spec.ts`

2. **API Client Usage**:
   - For pure API tests, use the `apiClient` fixture
   - For UI tests with API support, use the appropriate client:
     - `currentSessionApiClient`: When you need the same session as the browser
     - `IsolatedAPIClient`: When you need a separate session

3. **API Test Structure**:
   ```typescript
   // tests/recruiter/api/sample.spec.ts
   import { test, expect } from "./fixtures.js";

   test.describe("Recruiter API Tests", () => {
     test("should login and fetch data", async ({ apiClient }) => {
       // Login
       await apiClient.auth.login("email@example.com", "password");
       
       // Make API call
       const response = await apiClient.request.get("/some/endpoint");
       
       // Assert response
       expect(response.ok()).toBe(true);
       expect(response.status()).toBe(200);
     });
   });
   ```

4. **Hybrid UI/API Tests**:
   ```typescript
   test("should use API and UI together", async ({ 
     page, 
     currentSessionApiClient, 
     assessmentOverviewPage 
   }) => {
     // UI login
     await page.goto("/login");
     // ...login steps...
     
     // API data setup using same session
     const apiResponse = await currentSessionApiClient.request.post("/create-data");
     const { id } = await apiResponse.json();
     
     // Continue with UI test using created data
     await assessmentOverviewPage.navigateTo(id);
   });
   ```

## Handling Flaky Tests

1. **Fix Flaky Tests Immediately**: Make this a priority
2. **Mark Unfixable Tests**: If a test cannot be immediately fixed, mark it with `.fixme`

```typescript
test.fixme('flaky test that needs fixing', async ({ loginPage }) => {
  // This test will be skipped until fixed
});
```
